<div>
   <p>
        The MSTest plugin can convert TRX format test reports into JUnit XML format so it can be recorded
        by Hudson.
   </p>

<h2>General Usage</h2>
   <p>To enable the MSTest plugin features you need to set up your build to run MSTest.exe (or VSTest.Console.exe) first. Example:
        <ul><code> "%PROGRAMFILES%\Microsoft Visual Studio 9.0\Common7\IDE\MSTest.exe" /runconfig:MyTestProject\LocalTestRun.testrunconfig /testcontainer:MyTestProject\bin\Release\MyTestProject.dll /resultsfile:TestResults\testResults.trx
       </code></ul>

       and then specify the path to the MSTest TRX file, 'TestResults/testResults.trx' in the above example.
   </p>
   <p>
       When using VSTest.Console.exe, you can't specify the path to the resulting TRX file. Thus, you can specify a pattern like 'TestResults/**/*.trx' (/ or \, that's the same).
   </p>
   <p>
        If you use the vstestrunner-plugin, the full path to the TRX file is exposed by an environment variable. So, you can also use an environment variable, like '$VSTEST_RESULT_TRX' or '${VSTEST_RESULT_TRX}'.
   </p>
   <p>
        In all the above examples, the ' character is there only to delimitate the pattern to use, and shall not be included in the pattern.
   </p>
<h2>Test Reporting Options</h2>
   <p>
        Test authors can control how each test appears in Hudson/Jenkins by writing specially formatted text to stdout (the console) at the beginning of the test method.  The following options are available:
        <ul><li>Append text to the test name (useful for data-driven test instances)</li>
            <li>Omit a test from Hudson/Jenkins (useful for some data-driven tests)</li>
            <li>Change the test's display name from the name of the test method to an alternate name (useful when reporting results to non-developers)</li>
        </ul>
        In all cases, the specially formatted text must be the first text to appear in the individual test's stdout.
    </p>
  <h3>Appending to a test's display name (naming each data-driven test instance)</h3>
    <p>
       You may want a test to appear in Jenkins with additional text appended to the usual name of the test method.  This is 
       particularly useful for data-driven tests, allowing you to give each individual test case an identifying suffix. To change a test's 
       display name, write the following line as the first text written to stdout during the test's execution:

        <ul><code>test-instance-name:<i>{test instance name}</i>:</code></ul>

       Replace "{test instance name}" with whatever text you want to have appended to the test name in Jenkins test reports.  For example, if a 
       test method is named <code>MyTestMethod</code>, and the first line of a particular execution of that test method is 
       <code>test-instance-name:Test Case A:</code>, that instance of the test will be displayed in Jenkins as <code>MyTestMethod.Test Case A</code>.  
       Colons are used to delimit the test instance name, so the instance name itself may not contain a colon.
    </p>
    <p>
      This option is particularly useful if you store the test case name as part of each data row in the data source.  You can then refer to 
      the name in the test itself:

        <ul><code>Console.WriteLine(String.Format("test-instance-name:{0}:", data_row("TestCaseName"))</code></ul>

      You could also use the values of the input parameters themselves as the test instance name: 

        <ul><code>Console.WriteLine(String.Format("test-instance-name:{0}, {1}:", data_row("param1"), data_row("param2"))</code></ul>

       Note that if you don't specify a <code>test-instance-name</code>, then data driven tests are automatically given a suffix based on 
       the data row ID (such as "row 3"), similar to what is displayed in Visual Studio.
    </p>

  <h3>Omitting a test from the test report</h3>
    <p>
      You may want a test to be removed from the test report.  This is useful in some data-driven test scenarios.  For example, consider a 
      set of input parameters in a data source, each of which will be provided to multiple tests.  Some inputs may not apply to certain tests.
      The testing framework will run each test against every available data row, even if the input doesn't apply to a particular test.  This
      option allows you to filter irrelevant test cases from the  test report.  The syntax is similar to the other options:

         <ul><code>omit-from-jenkins:true</code></ul>

      Like the other reporting options, this must be the first line of text written to stdout during the execution of the test you want to filter 
      from the test report.
    </p>
<h4>Example</h4>
    <p>
      Here is an example of how this capability might be used.  Consider a data source with the following data:

         <ul><table border="1">
           <thead><tr><th>TestCaseName</th><th>Param1</th><th>ExpectedResult1</th><th>ExpectedResult2</th></tr></thead>
           <tr><td>Case A</td><td>"Input1"</td><td>3.1</td><td>1.7</td></tr>
           <tr><td>Case B</td><td>"Input2"</td><td>0.9</td><td>1.0</td></tr>
           <tr><td>Case C</td><td>"Input3"</td><td>4.2</td><td></td></tr>
         </table></ul>

      In this example, Test1 applies to all 3 data rows, with the expected result specified as ExpectedResult1.  Test2, however, only applies 
      to the first 2 data rows; the test does not apply to Case C, as indicated by the blank ExpectedResult2 for that data row.  The test 
      method will need to recognize which test cases to ignore, and write reporting instructions accordingly:

       <ul><code><pre>
     [DataSource("blah blah blah")]
     [TestMethod()]
     public void Test2()
     {
        if (testContext.DataRow("ExpectedResult2") = null) {
            Console.WriteLine("omit-from-jenkins:true");
            return;
        }

        Console.WriteLine(String.Format("test-instance-name:{0}:", testContext.DataRow("TestCaseName"));
        // do test logic
        ...
     }  
     </pre></code></ul>
  </p>

  <h3>Changing a test's display name</h3>
   <p>
       You may want a test to appear in Jenkins with a different name than the name of the test method, possibly to provide a more 
       readable name than the name of the test method.  To change a test's display name, write the following line as the first text 
       written to stdout during the test's execution:

         <ul><code>test-alternate-name:<i>{alternate name}</i>:</code></ul>

       Replace "{alternate name}" with whatever text you want to use as the name of the test in Jenkins reports.  For example, 
       <code>test-alternate-name:My Test:</code> will be displayed in Jenkins as <code>My Test</code>.  Colons are used to delimit the alternate 
       test name, so the alternate name itself may not contain a colon.
    </p>

</div>


